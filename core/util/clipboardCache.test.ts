// Generated by continue
import { clipboardCache } from "./clipboardCache";

describe("ClipboardCache", () => {
  beforeEach(() => {
    clipboardCache.clear();
  });

  describe("add", () => {
    it("should add items to the cache", () => {
      clipboardCache.add("1", "content1");
      expect(clipboardCache.get("1")).toBe("content1");
    });

    it("should not add empty content", () => {
      clipboardCache.add("1", "");
      expect(clipboardCache.get("1")).toBeUndefined();
    });

    it("should maintain ordered items up to maxSize", () => {
      // Add 31 items (maxSize is 30)
      for (let i = 0; i < 31; i++) {
        clipboardCache.add(i.toString(), `content${i}`);
      }

      const items = clipboardCache.getNItems(31);
      expect(items.length).toBe(30);
      // Most recent item should be first
      expect(items[0].content).toBe("content30");
      // Oldest item (content0) should be removed
      expect(clipboardCache.get("0")).toBeUndefined();
    });
  });

  describe("getNItems", () => {
    beforeEach(() => {
      for (let i = 0; i < 5; i++) {
        clipboardCache.add(i.toString(), `content${i}`);
      }
    });

    it("should return the requested number of items in order", () => {
      const items = clipboardCache.getNItems(3);
      expect(items.length).toBe(3);
      expect(items[0]).toEqual({ id: "4", content: "content4" });
      expect(items[1]).toEqual({ id: "3", content: "content3" });
      expect(items[2]).toEqual({ id: "2", content: "content2" });
    });

    it("should return all items if count exceeds cache size", () => {
      const items = clipboardCache.getNItems(10);
      expect(items.length).toBe(5);
    });
  });

  describe("get", () => {
    it("should return undefined for non-existent items", () => {
      expect(clipboardCache.get("nonexistent")).toBeUndefined();
    });

    it("should return content for existing items", () => {
      clipboardCache.add("1", "content1");
      expect(clipboardCache.get("1")).toBe("content1");
    });
  });

  describe("select", () => {
    beforeEach(() => {
      for (let i = 0; i < 3; i++) {
        clipboardCache.add(i.toString(), `content${i}`);
      }
    });

    it("should move selected item to front of order", () => {
      clipboardCache.select("1");
      const items = clipboardCache.getNItems(3);
      expect(items[0].id).toBe("1");
    });

    it("should do nothing for non-existent items", () => {
      const beforeItems = clipboardCache.getNItems(3);
      clipboardCache.select("nonexistent");
      const afterItems = clipboardCache.getNItems(3);
      expect(afterItems).toEqual(beforeItems);
    });
  });

  describe("clear", () => {
    it("should remove all items from cache", () => {
      clipboardCache.add("1", "content1");
      clipboardCache.add("2", "content2");
      clipboardCache.clear();
      expect(clipboardCache.getNItems(10)).toEqual([]);
      expect(clipboardCache.get("1")).toBeUndefined();
      expect(clipboardCache.get("2")).toBeUndefined();
    });
  });
});

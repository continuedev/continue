// Generated by continue

import { resolveRelativePathInWorkspace } from "./ideUtils";
import { testIde } from "../test/fixtures";
import { IDE } from "..";

describe("resolveRelativePathInWorkspace", () => {
  let mockIde: IDE;

  beforeEach(() => {
    mockIde = testIde;
  });

  it("should return the full path if the path is already absolute", async () => {
    const mockPath = "/absolute/path/to/file.txt";
    jest.spyOn(mockIde, "pathSep").mockResolvedValue("/");

    const result = await resolveRelativePathInWorkspace(mockPath, mockIde);
    expect(result).toBe(mockPath);
  });

  it("should resolve a relative path to a full path within workspace directories", async () => {
    const relativePath = "relative/path/to/file.txt";
    const workspaces = ["/workspace/one", "/workspace/two"];
    const expectedFullPath = `/workspace/one/${relativePath}`;

    jest.spyOn(mockIde, "pathSep").mockResolvedValue("/");
    jest.spyOn(mockIde, "getWorkspaceDirs").mockResolvedValue(workspaces);
    jest
      .spyOn(mockIde, "fileExists")
      .mockImplementation(async (path) => path === expectedFullPath);

    const result = await resolveRelativePathInWorkspace(relativePath, mockIde);
    expect(result).toBe(expectedFullPath);
  });

  it("should return undefined if the relative path does not exist in any workspace directory", async () => {
    const relativePath = "non/existent/path.txt";
    const workspaces = ["/workspace/one", "/workspace/two"];

    jest.spyOn(mockIde, "pathSep").mockResolvedValue("/");
    jest.spyOn(mockIde, "getWorkspaceDirs").mockResolvedValue(workspaces);
    jest.spyOn(mockIde, "fileExists").mockResolvedValue(false);

    const result = await resolveRelativePathInWorkspace(relativePath, mockIde);
    expect(result).toBeUndefined();
  });
});

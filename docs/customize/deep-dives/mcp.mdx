---
title: "How to Set Up Model Context Protocol (MCP) in Continue"
description: MCP use and customization
keywords: [tool, use, function calling, claude, automatic]
sidebarTitle: "Model Context Protocol (MCP)"
---

As AI systems get better, they're still held back by their training data and
can't access real-time information or specialized tools. The [Model Context
Protocol](https://modelcontextprotocol.io/introduction) (MCP) fixes this by
letting AI models connect with outside data sources, tools, and environments.
This allows smooth sharing of information and abilities between AI systems and
the wider digital world. This standard, created by Anthropic to bring together
prompts, context, and tool use, is key for building truly useful AI experiences
that can be set up with custom tools.

## How MCP Works in Continue

Currently custom tools can be configured using the Model Context
Protocol standard to unify prompts, context, and tool use.

MCP Servers can be added to hub Agents using `mcpServers` blocks. You can
explore available MCP server blocks
[here](https://hub.continue.dev/explore/mcp).

<Info>MCP can only be used in the **agent** mode.</Info>

## Quick Start: How to Set Up Your First MCP Server

Below is a quick example of setting up a new MCP server for use in your agent:

1. Create a folder called `.continue/mcpServers` at the top level of your workspace
2. Add a file called `playwright-mcp.yaml` to this folder.
3. Write the following contents to `playwright-mcp.yaml` and save.

```yaml title=".continue/mcpServers/playwright-mcp.yaml"
name: Playwright mcpServer
version: 0.0.1
schema: v1
mcpServers:
  - name: Browser search
    command: npx
    args:
      - "@playwright/mcp@latest"
```

Now test your MCP server by prompting the following command:

```
Open the browser and navigate Hacker News. Save the top 10 headlines in a hn.txt file.
```

The result will be a generated file called `hn.txt` in the current working directory.

![playwright mcp](/images/mcp-playwright.png)

## How to Set Up Continue Documentation Search with MCP

You can set up an MCP server to search the Continue documentation directly from your agent. This is particularly useful for getting help with Continue configuration and features.

For complete setup instructions, troubleshooting, and usage examples, see the [Continue MCP Reference](/reference/continue-mcp).

## How to Configure MCP Servers

To set up your own MCP server, read the [MCP
quickstart](https://modelcontextprotocol.io/quickstart) and then [create an
`mcpServers`
block](https://hub.continue.dev/new?type=block&blockType=mcpServers) or add a local MCP
server block to your [config file](./configuration.md):

<Tabs>
  <Tab title="YAML">
  ```yaml title="config.yaml"
  mcpServers:
    - name: SQLite MCP
      command: npx
      args:
        - "-y"
        - "mcp-sqlite"
        - "/path/to/your/database.db"
  ```
  </Tab>
  <Tab title="JSON">
  ```json title="config.json"
  {
    "experimental": {
      "modelContextProtocolServers": [
        {
          "transport": {
            "type": "stdio",
            "command": "uvx",
            "args": ["mcp-server-sqlite", "--db-path", "/path/to/your/database.db"]
          }
      }
      ]
    }
  }
  ```
  </Tab>
</Tabs>

### How to Configure MCP Server Properties

MCP blocks follow the established syntax for blocks, with a few additional properties specific to MCP servers.

- `name`: A display name for the MCP server.
- `type`: The type of the MCP server: `sse`, `stdio`, `streamable-http`
- `command`: The command to run to start the MCP server.
- `args`: Arguments to pass to the command.
- `env`: Secrets to be injected into the command as environment variables.

### How to Choose MCP Transport Types

MCP now supports remote server connections through HTTP-based transports, expanding beyond the traditional local stdio transport method. This enables integration with cloud-hosted MCP servers and distributed architectures.

#### How to Use Server-Sent Events Transport (`sse`)

For real-time streaming communication, use the SSE transport:

```yaml
mcpServers:
  - name: Name
    type: sse
    url: https://....
```

#### How to Use Standard Input/Output (`stdio`)

For local MCP servers that communicate via standard input and output:

```yaml
mcpServers:
  - name: Name
    type: stdio
    command: npx
    args:
      - "@modelcontextprotocol/server-sqlite"
      - "/path/to/your/database.db"
```

#### How to Use Streamable HTTP Transport

For standard HTTP-based communication with streaming capabilities:

```yaml
mcpServers:
  - name: Name
    type: streamable-http
    url: https://....
```

These remote transport options allow you to connect to MCP servers hosted on remote infrastructure, enabling more flexible deployment architectures and shared server resources across multiple clients.

For detailed information about transport mechanisms and their use cases, refer to the official MCP documentation on [transports](https://modelcontextprotocol.io/docs/concepts/transports#server-sent-events-sse).

### How to Work with Secrets in MCP Servers

With some MCP servers you will need to use API keys or other secrets. You can leverage locally stored environments secrets
as well as access hosted secrets in the Continue Hub. To leverage Hub secrets, you can use the `inputs` property in your MCP env block instead of `secrets`.

```yaml
mcpServers:
  - name: Supabase MCP
    command: npx
    args:
      - -y
      - "@supabase/mcp-server-supabase@latest"
      - --access-token
      - ${{ secrets.SUPABASE_TOKEN }}
    env:
      SUPABASE_TOKEN: ${{ secrets.SUPABASE_TOKEN }}
  - name: GitHub
    command: npx
    args:
      - "-y"
      - "@modelcontextprotocol/server-github"
    env:
      GITHUB_PERSONAL_ACCESS_TOKEN: ${{ secrets.GITHUB_PERSONAL_ACCESS_TOKEN }}
```

#### Environment Variable Secret Resolution

<Info>

  When using Continue CLI with MCP servers, secrets are automatically resolved from your local environment variables. This provides a secure way to use sensitive data without hardcoding it in your configuration.

</Info>

For Continue CLI users, `${{ secrets.SECRET_NAME }}` template variables in your MCP server configuration will be automatically replaced with values from `process.env.SECRET_NAME`. This works in **all string values** of your MCP server configuration, including:

<Warning>

  Secret templating only works in **values**, not in object **keys**. For example, `headers: { "Authorization": "Bearer ${{ secrets.TOKEN }}" }` works, but `headers: { "${{ secrets.HEADER_NAME }}": "value" }` does not.

</Warning>

**For STDIO servers (`command` type):**
- `command` - The executable command
- `args` - Array of command arguments  
- `env` - Environment variable values (secrets in keys are not supported)
- `cwd` - Working directory path

**For HTTP-based servers (`sse` and `streamable-http` types):**
- `url` - The server endpoint URL
- `requestOptions.headers` - HTTP header values (secrets in keys are not supported)
- All other `requestOptions` fields that are strings

**For all server types:**
- `name` - Server display name
- `faviconUrl` - Icon URL
- Any other string fields in the configuration

**Example with environment variables:**

```yaml
mcpServers:
  # STDIO server example with secrets in various fields
  - name: ${{ secrets.SERVER_NAME }}  # Server name from env
    command: ${{ secrets.CUSTOM_COMMAND }}  # Command from env
    args:
      - server.js
      - --api-key
      - ${{ secrets.API_KEY }}  # Command argument
      - --config-path
      - ${{ secrets.CONFIG_PATH }}  # File path
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}  # Env variable value
      CUSTOM_SECRET: ${{ secrets.ENV_SECRET }}  # Another env var value
      LOG_LEVEL: info  # Regular value (no templating)
    cwd: ${{ secrets.WORKING_DIR }}  # Working directory
    
  # HTTP server example with secrets in URL and headers
  - name: Remote API Server
    type: sse
    url: ${{ secrets.API_BASE_URL }}/mcp  # URL with secret
    requestOptions:
      headers:
        Authorization: Bearer ${{ secrets.AUTH_TOKEN }}  # Header value
        X-Custom-Value: ${{ secrets.CUSTOM_HEADER_VALUE }}  # Another header value
        X-User-ID: ${{ secrets.USER_ID }}  # Another header
        Content-Type: application/json  # Regular header
```

**Setting environment variables:**

```bash
# Set environment variables before running Continue CLI
export SERVER_NAME="My Custom Server"
export CUSTOM_COMMAND="node"
export API_KEY="your-secret-api-key"
export CONFIG_PATH="/path/to/config.json"
export DATABASE_URL="postgresql://user:pass@host:5432/db"
export ENV_SECRET="custom-env-value"
export WORKING_DIR="/app/workspace"
export API_BASE_URL="https://api.example.com"
export AUTH_TOKEN="bearer-token-123"
export CUSTOM_HEADER_VALUE="custom-header-value"
export USER_ID="user123"

# Then run Continue CLI - secrets will be automatically resolved
continue
```

**Validation and warnings:**

- If an environment variable is not found, the original template variable is preserved (e.g., `${{ secrets.MISSING_KEY }}`)
- The CLI will display warnings for any unrendered secrets to help with debugging
- All secret resolution happens at connection time, ensuring fresh values on server restarts

This approach provides a secure way to manage secrets locally while maintaining compatibility with the template variable syntax used in Continue Hub configurations.
